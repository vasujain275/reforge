// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: attempts.sql

package repo

import (
	"context"
	"database/sql"
)

const createAttempt = `-- name: CreateAttempt :one
INSERT INTO attempts (user_id, problem_id, session_id, confidence_score, duration_seconds, outcome, notes, performed_at)
VALUES (?, ?, ?, ?, ?, ?, ?, COALESCE(?, CURRENT_TIMESTAMP))
RETURNING id, user_id, problem_id, session_id, confidence_score, duration_seconds, outcome, notes, performed_at
`

type CreateAttemptParams struct {
	UserID          int64          `json:"user_id"`
	ProblemID       int64          `json:"problem_id"`
	SessionID       sql.NullInt64  `json:"session_id"`
	ConfidenceScore sql.NullInt64  `json:"confidence_score"`
	DurationSeconds sql.NullInt64  `json:"duration_seconds"`
	Outcome         sql.NullString `json:"outcome"`
	Notes           sql.NullString `json:"notes"`
	Column8         interface{}    `json:"column_8"`
}

func (q *Queries) CreateAttempt(ctx context.Context, arg CreateAttemptParams) (Attempt, error) {
	row := q.db.QueryRowContext(ctx, createAttempt,
		arg.UserID,
		arg.ProblemID,
		arg.SessionID,
		arg.ConfidenceScore,
		arg.DurationSeconds,
		arg.Outcome,
		arg.Notes,
		arg.Column8,
	)
	var i Attempt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProblemID,
		&i.SessionID,
		&i.ConfidenceScore,
		&i.DurationSeconds,
		&i.Outcome,
		&i.Notes,
		&i.PerformedAt,
	)
	return i, err
}

const getAttempt = `-- name: GetAttempt :one
SELECT id, user_id, problem_id, session_id, confidence_score, duration_seconds, outcome, notes, performed_at FROM attempts
WHERE id = ? AND user_id = ?
LIMIT 1
`

type GetAttemptParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) GetAttempt(ctx context.Context, arg GetAttemptParams) (Attempt, error) {
	row := q.db.QueryRowContext(ctx, getAttempt, arg.ID, arg.UserID)
	var i Attempt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProblemID,
		&i.SessionID,
		&i.ConfidenceScore,
		&i.DurationSeconds,
		&i.Outcome,
		&i.Notes,
		&i.PerformedAt,
	)
	return i, err
}

const getLatestAttemptForProblemInSession = `-- name: GetLatestAttemptForProblemInSession :one
SELECT id, user_id, problem_id, session_id, confidence_score, duration_seconds, outcome, notes, performed_at FROM attempts
WHERE user_id = ? AND problem_id = ? AND session_id = ?
ORDER BY performed_at DESC
LIMIT 1
`

type GetLatestAttemptForProblemInSessionParams struct {
	UserID    int64         `json:"user_id"`
	ProblemID int64         `json:"problem_id"`
	SessionID sql.NullInt64 `json:"session_id"`
}

func (q *Queries) GetLatestAttemptForProblemInSession(ctx context.Context, arg GetLatestAttemptForProblemInSessionParams) (Attempt, error) {
	row := q.db.QueryRowContext(ctx, getLatestAttemptForProblemInSession, arg.UserID, arg.ProblemID, arg.SessionID)
	var i Attempt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProblemID,
		&i.SessionID,
		&i.ConfidenceScore,
		&i.DurationSeconds,
		&i.Outcome,
		&i.Notes,
		&i.PerformedAt,
	)
	return i, err
}

const getRecentAttempts = `-- name: GetRecentAttempts :many
SELECT a.id, a.user_id, a.problem_id, a.session_id, a.confidence_score, a.duration_seconds, a.outcome, a.notes, a.performed_at, p.title as problem_title, p.difficulty as problem_difficulty
FROM attempts a
JOIN problems p ON a.problem_id = p.id
WHERE a.user_id = ?
ORDER BY a.performed_at DESC
LIMIT ?
`

type GetRecentAttemptsParams struct {
	UserID int64 `json:"user_id"`
	Limit  int64 `json:"limit"`
}

type GetRecentAttemptsRow struct {
	ID                int64          `json:"id"`
	UserID            int64          `json:"user_id"`
	ProblemID         int64          `json:"problem_id"`
	SessionID         sql.NullInt64  `json:"session_id"`
	ConfidenceScore   sql.NullInt64  `json:"confidence_score"`
	DurationSeconds   sql.NullInt64  `json:"duration_seconds"`
	Outcome           sql.NullString `json:"outcome"`
	Notes             sql.NullString `json:"notes"`
	PerformedAt       sql.NullString `json:"performed_at"`
	ProblemTitle      string         `json:"problem_title"`
	ProblemDifficulty sql.NullString `json:"problem_difficulty"`
}

func (q *Queries) GetRecentAttempts(ctx context.Context, arg GetRecentAttemptsParams) ([]GetRecentAttemptsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentAttempts, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentAttemptsRow{}
	for rows.Next() {
		var i GetRecentAttemptsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProblemID,
			&i.SessionID,
			&i.ConfidenceScore,
			&i.DurationSeconds,
			&i.Outcome,
			&i.Notes,
			&i.PerformedAt,
			&i.ProblemTitle,
			&i.ProblemDifficulty,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttemptsForProblem = `-- name: ListAttemptsForProblem :many
SELECT id, user_id, problem_id, session_id, confidence_score, duration_seconds, outcome, notes, performed_at FROM attempts
WHERE user_id = ? AND problem_id = ?
ORDER BY performed_at DESC
`

type ListAttemptsForProblemParams struct {
	UserID    int64 `json:"user_id"`
	ProblemID int64 `json:"problem_id"`
}

func (q *Queries) ListAttemptsForProblem(ctx context.Context, arg ListAttemptsForProblemParams) ([]Attempt, error) {
	rows, err := q.db.QueryContext(ctx, listAttemptsForProblem, arg.UserID, arg.ProblemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Attempt{}
	for rows.Next() {
		var i Attempt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProblemID,
			&i.SessionID,
			&i.ConfidenceScore,
			&i.DurationSeconds,
			&i.Outcome,
			&i.Notes,
			&i.PerformedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttemptsForUser = `-- name: ListAttemptsForUser :many
SELECT a.id, a.user_id, a.problem_id, a.session_id, a.confidence_score, a.duration_seconds, a.outcome, a.notes, a.performed_at, p.title as problem_title, p.difficulty as problem_difficulty
FROM attempts a
JOIN problems p ON a.problem_id = p.id
WHERE a.user_id = ?
ORDER BY a.performed_at DESC
LIMIT ? OFFSET ?
`

type ListAttemptsForUserParams struct {
	UserID int64 `json:"user_id"`
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type ListAttemptsForUserRow struct {
	ID                int64          `json:"id"`
	UserID            int64          `json:"user_id"`
	ProblemID         int64          `json:"problem_id"`
	SessionID         sql.NullInt64  `json:"session_id"`
	ConfidenceScore   sql.NullInt64  `json:"confidence_score"`
	DurationSeconds   sql.NullInt64  `json:"duration_seconds"`
	Outcome           sql.NullString `json:"outcome"`
	Notes             sql.NullString `json:"notes"`
	PerformedAt       sql.NullString `json:"performed_at"`
	ProblemTitle      string         `json:"problem_title"`
	ProblemDifficulty sql.NullString `json:"problem_difficulty"`
}

func (q *Queries) ListAttemptsForUser(ctx context.Context, arg ListAttemptsForUserParams) ([]ListAttemptsForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listAttemptsForUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAttemptsForUserRow{}
	for rows.Next() {
		var i ListAttemptsForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProblemID,
			&i.SessionID,
			&i.ConfidenceScore,
			&i.DurationSeconds,
			&i.Outcome,
			&i.Notes,
			&i.PerformedAt,
			&i.ProblemTitle,
			&i.ProblemDifficulty,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
