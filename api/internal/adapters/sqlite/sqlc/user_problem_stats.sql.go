// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_problem_stats.sql

package repo

import (
	"context"
	"database/sql"
)

const createUserProblemStats = `-- name: CreateUserProblemStats :one
INSERT INTO user_problem_stats (
    user_id, problem_id, status, confidence, avg_confidence,
    last_attempt_at, total_attempts, avg_time_seconds, last_outcome, recent_history_json,
    next_review_at, interval_days, ease_factor, review_count
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, user_id, problem_id, status, confidence, avg_confidence, last_attempt_at, total_attempts, avg_time_seconds, last_outcome, recent_history_json, updated_at, next_review_at, interval_days, ease_factor, review_count
`

type CreateUserProblemStatsParams struct {
	UserID            int64           `json:"user_id"`
	ProblemID         int64           `json:"problem_id"`
	Status            sql.NullString  `json:"status"`
	Confidence        sql.NullInt64   `json:"confidence"`
	AvgConfidence     sql.NullInt64   `json:"avg_confidence"`
	LastAttemptAt     sql.NullString  `json:"last_attempt_at"`
	TotalAttempts     sql.NullInt64   `json:"total_attempts"`
	AvgTimeSeconds    sql.NullInt64   `json:"avg_time_seconds"`
	LastOutcome       sql.NullString  `json:"last_outcome"`
	RecentHistoryJson sql.NullString  `json:"recent_history_json"`
	NextReviewAt      sql.NullString  `json:"next_review_at"`
	IntervalDays      sql.NullInt64   `json:"interval_days"`
	EaseFactor        sql.NullFloat64 `json:"ease_factor"`
	ReviewCount       sql.NullInt64   `json:"review_count"`
}

func (q *Queries) CreateUserProblemStats(ctx context.Context, arg CreateUserProblemStatsParams) (UserProblemStat, error) {
	row := q.db.QueryRowContext(ctx, createUserProblemStats,
		arg.UserID,
		arg.ProblemID,
		arg.Status,
		arg.Confidence,
		arg.AvgConfidence,
		arg.LastAttemptAt,
		arg.TotalAttempts,
		arg.AvgTimeSeconds,
		arg.LastOutcome,
		arg.RecentHistoryJson,
		arg.NextReviewAt,
		arg.IntervalDays,
		arg.EaseFactor,
		arg.ReviewCount,
	)
	var i UserProblemStat
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProblemID,
		&i.Status,
		&i.Confidence,
		&i.AvgConfidence,
		&i.LastAttemptAt,
		&i.TotalAttempts,
		&i.AvgTimeSeconds,
		&i.LastOutcome,
		&i.RecentHistoryJson,
		&i.UpdatedAt,
		&i.NextReviewAt,
		&i.IntervalDays,
		&i.EaseFactor,
		&i.ReviewCount,
	)
	return i, err
}

const getAverageConfidenceForUser = `-- name: GetAverageConfidenceForUser :one
SELECT COALESCE(AVG(confidence), 0) as avg_confidence
FROM user_problem_stats
WHERE user_id = ? AND status != 'abandoned'
`

func (q *Queries) GetAverageConfidenceForUser(ctx context.Context, userID int64) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getAverageConfidenceForUser, userID)
	var avg_confidence interface{}
	err := row.Scan(&avg_confidence)
	return avg_confidence, err
}

const getMasteredProblemsForUser = `-- name: GetMasteredProblemsForUser :one
SELECT COUNT(*) as count
FROM user_problem_stats
WHERE user_id = ? AND status = 'solved' AND confidence >= 80
`

func (q *Queries) GetMasteredProblemsForUser(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getMasteredProblemsForUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getOverdueProblemsCount = `-- name: GetOverdueProblemsCount :one
SELECT COUNT(*) as count
FROM user_problem_stats
WHERE user_id = ? 
  AND status != 'abandoned'
  AND next_review_at IS NOT NULL 
  AND next_review_at < datetime('now')
`

func (q *Queries) GetOverdueProblemsCount(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getOverdueProblemsCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getProblemsForReview = `-- name: GetProblemsForReview :many
SELECT ups.id, ups.user_id, ups.problem_id, ups.status, ups.confidence, ups.avg_confidence, ups.last_attempt_at, ups.total_attempts, ups.avg_time_seconds, ups.last_outcome, ups.recent_history_json, ups.updated_at, ups.next_review_at, ups.interval_days, ups.ease_factor, ups.review_count, p.title, p.source, p.url, p.difficulty, p.created_at as problem_created_at
FROM user_problem_stats ups
JOIN problems p ON ups.problem_id = p.id
WHERE ups.user_id = ? 
  AND ups.status != 'abandoned'
  AND (ups.next_review_at IS NULL OR ups.next_review_at <= ?)
ORDER BY ups.next_review_at ASC NULLS FIRST
LIMIT ?
`

type GetProblemsForReviewParams struct {
	UserID       int64          `json:"user_id"`
	NextReviewAt sql.NullString `json:"next_review_at"`
	Limit        int64          `json:"limit"`
}

type GetProblemsForReviewRow struct {
	ID                int64           `json:"id"`
	UserID            int64           `json:"user_id"`
	ProblemID         int64           `json:"problem_id"`
	Status            sql.NullString  `json:"status"`
	Confidence        sql.NullInt64   `json:"confidence"`
	AvgConfidence     sql.NullInt64   `json:"avg_confidence"`
	LastAttemptAt     sql.NullString  `json:"last_attempt_at"`
	TotalAttempts     sql.NullInt64   `json:"total_attempts"`
	AvgTimeSeconds    sql.NullInt64   `json:"avg_time_seconds"`
	LastOutcome       sql.NullString  `json:"last_outcome"`
	RecentHistoryJson sql.NullString  `json:"recent_history_json"`
	UpdatedAt         sql.NullString  `json:"updated_at"`
	NextReviewAt      sql.NullString  `json:"next_review_at"`
	IntervalDays      sql.NullInt64   `json:"interval_days"`
	EaseFactor        sql.NullFloat64 `json:"ease_factor"`
	ReviewCount       sql.NullInt64   `json:"review_count"`
	Title             string          `json:"title"`
	Source            sql.NullString  `json:"source"`
	Url               sql.NullString  `json:"url"`
	Difficulty        sql.NullString  `json:"difficulty"`
	ProblemCreatedAt  sql.NullString  `json:"problem_created_at"`
}

func (q *Queries) GetProblemsForReview(ctx context.Context, arg GetProblemsForReviewParams) ([]GetProblemsForReviewRow, error) {
	rows, err := q.db.QueryContext(ctx, getProblemsForReview, arg.UserID, arg.NextReviewAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProblemsForReviewRow{}
	for rows.Next() {
		var i GetProblemsForReviewRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProblemID,
			&i.Status,
			&i.Confidence,
			&i.AvgConfidence,
			&i.LastAttemptAt,
			&i.TotalAttempts,
			&i.AvgTimeSeconds,
			&i.LastOutcome,
			&i.RecentHistoryJson,
			&i.UpdatedAt,
			&i.NextReviewAt,
			&i.IntervalDays,
			&i.EaseFactor,
			&i.ReviewCount,
			&i.Title,
			&i.Source,
			&i.Url,
			&i.Difficulty,
			&i.ProblemCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalProblemsForUser = `-- name: GetTotalProblemsForUser :one
SELECT COUNT(DISTINCT problem_id) as count
FROM user_problem_stats
WHERE user_id = ?
`

func (q *Queries) GetTotalProblemsForUser(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalProblemsForUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUrgentProblems = `-- name: GetUrgentProblems :many
SELECT ups.id, ups.user_id, ups.problem_id, ups.status, ups.confidence, ups.avg_confidence, ups.last_attempt_at, ups.total_attempts, ups.avg_time_seconds, ups.last_outcome, ups.recent_history_json, ups.updated_at, ups.next_review_at, ups.interval_days, ups.ease_factor, ups.review_count, p.title, p.source, p.url, p.difficulty, p.created_at as problem_created_at
FROM user_problem_stats ups
JOIN problems p ON ups.problem_id = p.id
WHERE ups.user_id = ? AND ups.status != 'abandoned'
ORDER BY ups.last_attempt_at ASC NULLS FIRST, ups.confidence ASC
LIMIT ?
`

type GetUrgentProblemsParams struct {
	UserID int64 `json:"user_id"`
	Limit  int64 `json:"limit"`
}

type GetUrgentProblemsRow struct {
	ID                int64           `json:"id"`
	UserID            int64           `json:"user_id"`
	ProblemID         int64           `json:"problem_id"`
	Status            sql.NullString  `json:"status"`
	Confidence        sql.NullInt64   `json:"confidence"`
	AvgConfidence     sql.NullInt64   `json:"avg_confidence"`
	LastAttemptAt     sql.NullString  `json:"last_attempt_at"`
	TotalAttempts     sql.NullInt64   `json:"total_attempts"`
	AvgTimeSeconds    sql.NullInt64   `json:"avg_time_seconds"`
	LastOutcome       sql.NullString  `json:"last_outcome"`
	RecentHistoryJson sql.NullString  `json:"recent_history_json"`
	UpdatedAt         sql.NullString  `json:"updated_at"`
	NextReviewAt      sql.NullString  `json:"next_review_at"`
	IntervalDays      sql.NullInt64   `json:"interval_days"`
	EaseFactor        sql.NullFloat64 `json:"ease_factor"`
	ReviewCount       sql.NullInt64   `json:"review_count"`
	Title             string          `json:"title"`
	Source            sql.NullString  `json:"source"`
	Url               sql.NullString  `json:"url"`
	Difficulty        sql.NullString  `json:"difficulty"`
	ProblemCreatedAt  sql.NullString  `json:"problem_created_at"`
}

func (q *Queries) GetUrgentProblems(ctx context.Context, arg GetUrgentProblemsParams) ([]GetUrgentProblemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUrgentProblems, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUrgentProblemsRow{}
	for rows.Next() {
		var i GetUrgentProblemsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProblemID,
			&i.Status,
			&i.Confidence,
			&i.AvgConfidence,
			&i.LastAttemptAt,
			&i.TotalAttempts,
			&i.AvgTimeSeconds,
			&i.LastOutcome,
			&i.RecentHistoryJson,
			&i.UpdatedAt,
			&i.NextReviewAt,
			&i.IntervalDays,
			&i.EaseFactor,
			&i.ReviewCount,
			&i.Title,
			&i.Source,
			&i.Url,
			&i.Difficulty,
			&i.ProblemCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserProblemStats = `-- name: GetUserProblemStats :one
SELECT id, user_id, problem_id, status, confidence, avg_confidence, last_attempt_at, total_attempts, avg_time_seconds, last_outcome, recent_history_json, updated_at, next_review_at, interval_days, ease_factor, review_count FROM user_problem_stats
WHERE user_id = ? AND problem_id = ?
LIMIT 1
`

type GetUserProblemStatsParams struct {
	UserID    int64 `json:"user_id"`
	ProblemID int64 `json:"problem_id"`
}

func (q *Queries) GetUserProblemStats(ctx context.Context, arg GetUserProblemStatsParams) (UserProblemStat, error) {
	row := q.db.QueryRowContext(ctx, getUserProblemStats, arg.UserID, arg.ProblemID)
	var i UserProblemStat
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProblemID,
		&i.Status,
		&i.Confidence,
		&i.AvgConfidence,
		&i.LastAttemptAt,
		&i.TotalAttempts,
		&i.AvgTimeSeconds,
		&i.LastOutcome,
		&i.RecentHistoryJson,
		&i.UpdatedAt,
		&i.NextReviewAt,
		&i.IntervalDays,
		&i.EaseFactor,
		&i.ReviewCount,
	)
	return i, err
}

const getUserProblemStatsWithProblem = `-- name: GetUserProblemStatsWithProblem :many
SELECT ups.id, ups.user_id, ups.problem_id, ups.status, ups.confidence, ups.avg_confidence, ups.last_attempt_at, ups.total_attempts, ups.avg_time_seconds, ups.last_outcome, ups.recent_history_json, ups.updated_at, ups.next_review_at, ups.interval_days, ups.ease_factor, ups.review_count, p.title, p.source, p.url, p.difficulty, p.created_at as problem_created_at
FROM user_problem_stats ups
JOIN problems p ON ups.problem_id = p.id
WHERE ups.user_id = ?
ORDER BY ups.updated_at DESC
`

type GetUserProblemStatsWithProblemRow struct {
	ID                int64           `json:"id"`
	UserID            int64           `json:"user_id"`
	ProblemID         int64           `json:"problem_id"`
	Status            sql.NullString  `json:"status"`
	Confidence        sql.NullInt64   `json:"confidence"`
	AvgConfidence     sql.NullInt64   `json:"avg_confidence"`
	LastAttemptAt     sql.NullString  `json:"last_attempt_at"`
	TotalAttempts     sql.NullInt64   `json:"total_attempts"`
	AvgTimeSeconds    sql.NullInt64   `json:"avg_time_seconds"`
	LastOutcome       sql.NullString  `json:"last_outcome"`
	RecentHistoryJson sql.NullString  `json:"recent_history_json"`
	UpdatedAt         sql.NullString  `json:"updated_at"`
	NextReviewAt      sql.NullString  `json:"next_review_at"`
	IntervalDays      sql.NullInt64   `json:"interval_days"`
	EaseFactor        sql.NullFloat64 `json:"ease_factor"`
	ReviewCount       sql.NullInt64   `json:"review_count"`
	Title             string          `json:"title"`
	Source            sql.NullString  `json:"source"`
	Url               sql.NullString  `json:"url"`
	Difficulty        sql.NullString  `json:"difficulty"`
	ProblemCreatedAt  sql.NullString  `json:"problem_created_at"`
}

func (q *Queries) GetUserProblemStatsWithProblem(ctx context.Context, userID int64) ([]GetUserProblemStatsWithProblemRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserProblemStatsWithProblem, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserProblemStatsWithProblemRow{}
	for rows.Next() {
		var i GetUserProblemStatsWithProblemRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProblemID,
			&i.Status,
			&i.Confidence,
			&i.AvgConfidence,
			&i.LastAttemptAt,
			&i.TotalAttempts,
			&i.AvgTimeSeconds,
			&i.LastOutcome,
			&i.RecentHistoryJson,
			&i.UpdatedAt,
			&i.NextReviewAt,
			&i.IntervalDays,
			&i.EaseFactor,
			&i.ReviewCount,
			&i.Title,
			&i.Source,
			&i.Url,
			&i.Difficulty,
			&i.ProblemCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllUserProblemStats = `-- name: ListAllUserProblemStats :many
SELECT id, user_id, problem_id, status, confidence, avg_confidence, last_attempt_at, total_attempts, avg_time_seconds, last_outcome, recent_history_json, updated_at, next_review_at, interval_days, ease_factor, review_count FROM user_problem_stats
ORDER BY user_id, problem_id
`

func (q *Queries) ListAllUserProblemStats(ctx context.Context) ([]UserProblemStat, error) {
	rows, err := q.db.QueryContext(ctx, listAllUserProblemStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserProblemStat{}
	for rows.Next() {
		var i UserProblemStat
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProblemID,
			&i.Status,
			&i.Confidence,
			&i.AvgConfidence,
			&i.LastAttemptAt,
			&i.TotalAttempts,
			&i.AvgTimeSeconds,
			&i.LastOutcome,
			&i.RecentHistoryJson,
			&i.UpdatedAt,
			&i.NextReviewAt,
			&i.IntervalDays,
			&i.EaseFactor,
			&i.ReviewCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserProblemStats = `-- name: ListUserProblemStats :many
SELECT id, user_id, problem_id, status, confidence, avg_confidence, last_attempt_at, total_attempts, avg_time_seconds, last_outcome, recent_history_json, updated_at, next_review_at, interval_days, ease_factor, review_count FROM user_problem_stats
WHERE user_id = ?
ORDER BY updated_at DESC
`

func (q *Queries) ListUserProblemStats(ctx context.Context, userID int64) ([]UserProblemStat, error) {
	rows, err := q.db.QueryContext(ctx, listUserProblemStats, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserProblemStat{}
	for rows.Next() {
		var i UserProblemStat
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProblemID,
			&i.Status,
			&i.Confidence,
			&i.AvgConfidence,
			&i.LastAttemptAt,
			&i.TotalAttempts,
			&i.AvgTimeSeconds,
			&i.LastOutcome,
			&i.RecentHistoryJson,
			&i.UpdatedAt,
			&i.NextReviewAt,
			&i.IntervalDays,
			&i.EaseFactor,
			&i.ReviewCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSpacedRepetition = `-- name: UpdateSpacedRepetition :exec
UPDATE user_problem_stats
SET next_review_at = ?,
    interval_days = ?,
    ease_factor = ?,
    review_count = review_count + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE user_id = ? AND problem_id = ?
`

type UpdateSpacedRepetitionParams struct {
	NextReviewAt sql.NullString  `json:"next_review_at"`
	IntervalDays sql.NullInt64   `json:"interval_days"`
	EaseFactor   sql.NullFloat64 `json:"ease_factor"`
	UserID       int64           `json:"user_id"`
	ProblemID    int64           `json:"problem_id"`
}

func (q *Queries) UpdateSpacedRepetition(ctx context.Context, arg UpdateSpacedRepetitionParams) error {
	_, err := q.db.ExecContext(ctx, updateSpacedRepetition,
		arg.NextReviewAt,
		arg.IntervalDays,
		arg.EaseFactor,
		arg.UserID,
		arg.ProblemID,
	)
	return err
}

const updateUserProblemStats = `-- name: UpdateUserProblemStats :one
UPDATE user_problem_stats
SET status = ?, confidence = ?, avg_confidence = ?,
    last_attempt_at = ?, total_attempts = ?, avg_time_seconds = ?,
    last_outcome = ?, recent_history_json = ?
WHERE user_id = ? AND problem_id = ?
RETURNING id, user_id, problem_id, status, confidence, avg_confidence, last_attempt_at, total_attempts, avg_time_seconds, last_outcome, recent_history_json, updated_at, next_review_at, interval_days, ease_factor, review_count
`

type UpdateUserProblemStatsParams struct {
	Status            sql.NullString `json:"status"`
	Confidence        sql.NullInt64  `json:"confidence"`
	AvgConfidence     sql.NullInt64  `json:"avg_confidence"`
	LastAttemptAt     sql.NullString `json:"last_attempt_at"`
	TotalAttempts     sql.NullInt64  `json:"total_attempts"`
	AvgTimeSeconds    sql.NullInt64  `json:"avg_time_seconds"`
	LastOutcome       sql.NullString `json:"last_outcome"`
	RecentHistoryJson sql.NullString `json:"recent_history_json"`
	UserID            int64          `json:"user_id"`
	ProblemID         int64          `json:"problem_id"`
}

func (q *Queries) UpdateUserProblemStats(ctx context.Context, arg UpdateUserProblemStatsParams) (UserProblemStat, error) {
	row := q.db.QueryRowContext(ctx, updateUserProblemStats,
		arg.Status,
		arg.Confidence,
		arg.AvgConfidence,
		arg.LastAttemptAt,
		arg.TotalAttempts,
		arg.AvgTimeSeconds,
		arg.LastOutcome,
		arg.RecentHistoryJson,
		arg.UserID,
		arg.ProblemID,
	)
	var i UserProblemStat
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProblemID,
		&i.Status,
		&i.Confidence,
		&i.AvgConfidence,
		&i.LastAttemptAt,
		&i.TotalAttempts,
		&i.AvgTimeSeconds,
		&i.LastOutcome,
		&i.RecentHistoryJson,
		&i.UpdatedAt,
		&i.NextReviewAt,
		&i.IntervalDays,
		&i.EaseFactor,
		&i.ReviewCount,
	)
	return i, err
}

const upsertUserProblemStats = `-- name: UpsertUserProblemStats :one
INSERT INTO user_problem_stats (
    user_id, problem_id, status, confidence, avg_confidence,
    last_attempt_at, total_attempts, avg_time_seconds, last_outcome, recent_history_json,
    next_review_at, interval_days, ease_factor, review_count
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(user_id, problem_id) DO UPDATE SET
    status = excluded.status,
    confidence = excluded.confidence,
    avg_confidence = excluded.avg_confidence,
    last_attempt_at = excluded.last_attempt_at,
    total_attempts = excluded.total_attempts,
    avg_time_seconds = excluded.avg_time_seconds,
    last_outcome = excluded.last_outcome,
    recent_history_json = excluded.recent_history_json,
    next_review_at = excluded.next_review_at,
    interval_days = excluded.interval_days,
    ease_factor = excluded.ease_factor,
    review_count = excluded.review_count
RETURNING id, user_id, problem_id, status, confidence, avg_confidence, last_attempt_at, total_attempts, avg_time_seconds, last_outcome, recent_history_json, updated_at, next_review_at, interval_days, ease_factor, review_count
`

type UpsertUserProblemStatsParams struct {
	UserID            int64           `json:"user_id"`
	ProblemID         int64           `json:"problem_id"`
	Status            sql.NullString  `json:"status"`
	Confidence        sql.NullInt64   `json:"confidence"`
	AvgConfidence     sql.NullInt64   `json:"avg_confidence"`
	LastAttemptAt     sql.NullString  `json:"last_attempt_at"`
	TotalAttempts     sql.NullInt64   `json:"total_attempts"`
	AvgTimeSeconds    sql.NullInt64   `json:"avg_time_seconds"`
	LastOutcome       sql.NullString  `json:"last_outcome"`
	RecentHistoryJson sql.NullString  `json:"recent_history_json"`
	NextReviewAt      sql.NullString  `json:"next_review_at"`
	IntervalDays      sql.NullInt64   `json:"interval_days"`
	EaseFactor        sql.NullFloat64 `json:"ease_factor"`
	ReviewCount       sql.NullInt64   `json:"review_count"`
}

func (q *Queries) UpsertUserProblemStats(ctx context.Context, arg UpsertUserProblemStatsParams) (UserProblemStat, error) {
	row := q.db.QueryRowContext(ctx, upsertUserProblemStats,
		arg.UserID,
		arg.ProblemID,
		arg.Status,
		arg.Confidence,
		arg.AvgConfidence,
		arg.LastAttemptAt,
		arg.TotalAttempts,
		arg.AvgTimeSeconds,
		arg.LastOutcome,
		arg.RecentHistoryJson,
		arg.NextReviewAt,
		arg.IntervalDays,
		arg.EaseFactor,
		arg.ReviewCount,
	)
	var i UserProblemStat
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProblemID,
		&i.Status,
		&i.Confidence,
		&i.AvgConfidence,
		&i.LastAttemptAt,
		&i.TotalAttempts,
		&i.AvgTimeSeconds,
		&i.LastOutcome,
		&i.RecentHistoryJson,
		&i.UpdatedAt,
		&i.NextReviewAt,
		&i.IntervalDays,
		&i.EaseFactor,
		&i.ReviewCount,
	)
	return i, err
}
